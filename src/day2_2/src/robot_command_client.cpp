// Dosya: ~/ros2_ws/src/advanced_robot/src/robot_command_client.cpp

#include <chrono>
#include <memory>
#include <string>
#include <iostream>
#include <sstream>

#include "rclcpp/rclcpp.hpp"
#include "day2/srv/robot_command.hpp"
#include "geometry_msgs/msg/point.hpp"
#include "geometry_msgs/msg/vector3.hpp"

using namespace std::chrono_literals;

/**
 * RobotCommandClient sƒ±nƒ±fƒ±
 * Interactive command line interface ile robot komutlarƒ± g√∂nderir
 */
class RobotCommandClient : public rclcpp::Node
{
public:
    RobotCommandClient() : Node("robot_command_client")
    {
        // Service client olu≈ütur
        client_ = this->create_client<day2::srv::RobotCommand>("robot_command");
        
        // Service server'ƒ±n hazƒ±r olmasƒ±nƒ± bekle
        while (!client_->wait_for_service(1s)) {
            if (!rclcpp::ok()) {
                RCLCPP_ERROR(this->get_logger(), "Client interrupted while waiting for service");
                return;
            }
            RCLCPP_INFO(this->get_logger(), "‚è≥ Waiting for robot_command service...");
        }
        
        RCLCPP_INFO(this->get_logger(), "‚úÖ Robot Command Client hazƒ±r!");
        RCLCPP_INFO(this->get_logger(), "Interactive mode ba≈ülatƒ±lƒ±yor...");
        
        // Interactive command loop ba≈ülat
        start_interactive_mode();
    }

private:
    /**
     * Interactive mode - kullanƒ±cƒ±dan komut al
     */
    void start_interactive_mode()
    {
        std::cout << "\nü§ñ === ROBOT COMMAND INTERFACE ===" << std::endl;
        std::cout << "Kullanƒ±labilir komutlar:" << std::endl;
        std::cout << "  1. move <x> <y> <z>     - Pozisyona git" << std::endl;
        std::cout << "  2. rotate <yaw>         - Belirtilen a√ßƒ±ya d√∂n (radyan)" << std::endl;
        std::cout << "  3. stop                 - Robotu durdur" << std::endl;
        std::cout << "  4. home                 - Home pozisyonuna git" << std::endl;
        std::cout << "  5. status               - Robot durumunu al" << std::endl;
        std::cout << "  6. help                 - Bu yardƒ±mƒ± g√∂ster" << std::endl;
        std::cout << "  7. exit                 - √áƒ±k" << std::endl;
        std::cout << "\n√ñrnekler:" << std::endl;
        std::cout << "  move 2.5 3.0 0.0" << std::endl;
        std::cout << "  rotate 1.57" << std::endl;
        std::cout << "  stop" << std::endl;
        std::cout << "\n" << std::endl;
        
        std::string input_line;
        while (rclcpp::ok()) {
            std::cout << "robot> ";
            std::getline(std::cin, input_line);
            
            if (input_line.empty()) continue;
            
            // Command'ƒ± parse et ve √ßalƒ±≈ütƒ±r
            if (!process_command(input_line)) {
                break; // exit komutu
            }
        }
    }
    
    /**
     * Kullanƒ±cƒ± komutunu parse et ve √ßalƒ±≈ütƒ±r
     */
    bool process_command(const std::string& input)
    {
        std::istringstream iss(input);
        std::string command;
        iss >> command;
        
        if (command == "exit" || command == "quit") {
            std::cout << "üëã Robot Command Client kapatƒ±lƒ±yor..." << std::endl;
            return false;
        }
        else if (command == "help") {
            show_help();
        }
        else if (command == "move") {
            handle_move_command(iss);
        }
        else if (command == "rotate") {
            handle_rotate_command(iss);
        }
        else if (command == "stop") {
            handle_stop_command();
        }
        else if (command == "home") {
            handle_home_command();
        }
        else if (command == "status") {
            handle_status_command();
        }
        else {
            std::cout << "‚ùå Bilinmeyen komut: " << command << std::endl;
            std::cout << "Yardƒ±m i√ßin 'help' yazƒ±n." << std::endl;
        }
        
        return true;
    }
    
    /**
     * Move komutunu i≈üle
     */
    void handle_move_command(std::istringstream& iss)
    {
        double x, y, z;
        if (!(iss >> x >> y >> z)) {
            std::cout << "‚ùå Hatalƒ± format! Kullanƒ±m: move <x> <y> <z>" << std::endl;
            return;
        }
        
        auto request = std::make_shared<day2::srv::RobotCommand::Request>();
        request->command_type = "move_to";
        request->target_position.x = x;
        request->target_position.y = y;
        request->target_position.z = z;
        request->max_velocity = 1.0; // Default hƒ±z
        request->max_acceleration = 0.5;
        request->timeout_seconds = 30.0;
        request->force_execution = false;
        
        send_command_async(request, "move");
    }
    
    /**
     * Rotate komutunu i≈üle
     */
    void handle_rotate_command(std::istringstream& iss)
    {
        double yaw;
        if (!(iss >> yaw)) {
            std::cout << "‚ùå Hatalƒ± format! Kullanƒ±m: rotate <yaw_radyan>" << std::endl;
            return;
        }
        
        auto request = std::make_shared<day2::srv::RobotCommand::Request>();
        request->command_type = "rotate";
        request->target_orientation.z = yaw;
        request->max_velocity = 1.0;
        request->timeout_seconds = 15.0;
        
        send_command_async(request, "rotate");
    }
    
    /**
     * Stop komutunu i≈üle
     */
    void handle_stop_command()
    {
        auto request = std::make_shared<day2::srv::RobotCommand::Request>();
        request->command_type = "stop";
        request->force_execution = true; // Acil durdurma
        
        send_command_async(request, "stop");
    }
    
    /**
     * Home komutunu i≈üle
     */
    void handle_home_command()
    {
        auto request = std::make_shared<day2::srv::RobotCommand::Request>();
        request->command_type = "home";
        request->max_velocity = 1.0;
        request->timeout_seconds = 30.0;
        
        send_command_async(request, "home");
    }
    
    /**
     * Status komutunu i≈üle
     */
    void handle_status_command()
    {
        auto request = std::make_shared<day2::srv::RobotCommand::Request>();
        request->command_type = "status";
        
        send_command_async(request, "status");
    }
    
    /**
     * Komutu asynchronous olarak g√∂nder
     */
    void send_command_async(
        std::shared_ptr<day2::srv::RobotCommand::Request> request,
        const std::string& command_name)
    {
        std::cout << "üì§ " << command_name << " komutu g√∂nderiliyor..." << std::endl;
        
        // Timestamp ekle
        request->deadline = this->get_clock()->now();
        request->deadline.sec += static_cast<int>(request->timeout_seconds);
        
        // Async call
        auto future = client_->async_send_request(request);
        
        // Response'u bekle (non-blocking i√ßin spin_until_future_complete kullan)
        if (rclcpp::spin_until_future_complete(this->get_node_base_interface(), future) ==
            rclcpp::FutureReturnCode::SUCCESS) {
            
            auto response = future.get();
            handle_service_response(response, command_name);
        } else {
            std::cout << "‚ùå Service call timeout! Robot yanƒ±t vermiyor." << std::endl;
        }
    }
    
    /**
     * Service response'unu i≈üle ve g√∂ster
     */
    void handle_service_response(
        std::shared_ptr<day2::srv::RobotCommand::Response> response,
        const std::string& command_name)
    {
        std::cout << "\nüì® === " << command_name << " KOMUTU YANITI ===" << std::endl;
        
        if (response->success) {
            std::cout << "‚úÖ Durum: BA≈ûARILI" << std::endl;
            std::cout << "üÜî Komut ID: " << response->command_id << std::endl;
            std::cout << "‚è±Ô∏è  Tahmini s√ºre: " << response->estimated_duration << " saniye" << std::endl;
            std::cout << "üí¨ Mesaj: " << response->message << std::endl;
            
            // Hedef pozisyon varsa g√∂ster
            if (command_name == "move" || command_name == "home") {
                std::cout << "üéØ Hedef pozisyon: (" 
                         << response->actual_target.x << ", "
                         << response->actual_target.y << ", "
                         << response->actual_target.z << ")" << std::endl;
            }
            
            // Completion time g√∂ster
            auto completion_time = rclcpp::Time(response->estimated_completion);
            auto now = this->get_clock()->now();
            auto time_diff = completion_time - now;
            std::cout << "üïê Tahmini tamamlanma: " << time_diff.seconds() << " saniye sonra" << std::endl;
            
        } else {
            std::cout << "‚ùå Durum: BA≈ûARISIZ" << std::endl;
            std::cout << "üî¢ Hata kodu: " << response->error_code << std::endl;
            std::cout << "üí¨ Hata mesajƒ±: " << response->message << std::endl;
            
            // Hata kodunu a√ßƒ±kla
            std::cout << "üìã Hata a√ßƒ±klamasƒ±: " << get_error_description(response->error_code) << std::endl;
        }
        
        std::cout << "========================================\n" << std::endl;
    }
    
    /**
     * Hata kodunu a√ßƒ±klayƒ±cƒ± metne √ßevir
     */
    std::string get_error_description(uint32_t error_code)
    {
        switch (error_code) {
            case day2::srv::RobotCommand::Response::ERROR_NONE:
                return "Hata yok";
            case day2::srv::RobotCommand::Response::ERROR_INVALID_COMMAND:
                return "Ge√ßersiz komut t√ºr√º";
            case day2::srv::RobotCommand::Response::ERROR_OUT_OF_BOUNDS:
                return "Hedef pozisyon eri≈üilebilir alan dƒ±≈üƒ±nda";
            case day2::srv::RobotCommand::Response::ERROR_ROBOT_BUSY:
                return "Robot ≈üu anda me≈ügul (ba≈üka komut √ßalƒ±≈üƒ±yor)";
            case day2::srv::RobotCommand::Response::ERROR_SAFETY_VIOLATION:
                return "G√ºvenlik kurallarƒ± ihlali";
            case day2::srv::RobotCommand::Response::ERROR_HARDWARE_FAILURE:
                return "Donanƒ±m arƒ±zasƒ±";
            case day2::srv::RobotCommand::Response::ERROR_TIMEOUT:
                return "Komut zaman a≈üƒ±mƒ±na uƒüradƒ±";
            default:
                return "Bilinmeyen hata kodu: " + std::to_string(error_code);
        }
    }
    
    /**
     * Yardƒ±m mesajƒ±nƒ± g√∂ster
     */
    void show_help()
    {
        std::cout << "\nüÜò === YARDIM ===" << std::endl;
        std::cout << "Komut formatlarƒ±:" << std::endl;
        std::cout << "  move <x> <y> <z>       - Robotu (x,y,z) pozisyonuna hareket ettir" << std::endl;
        std::cout << "                           √ñrnek: move 2.0 3.5 0.0" << std::endl;
        std::cout << "  rotate <yaw>           - Robotu belirtilen a√ßƒ±ya d√∂nd√ºr (radyan)" << std::endl;
        std::cout << "                           √ñrnek: rotate 1.57 (90 derece)" << std::endl;
        std::cout << "  stop                   - Robotu anƒ±nda durdur" << std::endl;
        std::cout << "  home                   - Robotu home pozisyonuna (0,0,0) g√∂nder" << std::endl;
        std::cout << "  status                 - Robot durumunu sorgula" << std::endl;
        std::cout << "  help                   - Bu yardƒ±mƒ± g√∂ster" << std::endl;
        std::cout << "  exit                   - Programdan √ßƒ±k" << std::endl;
        std::cout << "\nNotlar:" << std::endl;
        std::cout << "  - Pozisyon limitleri: x,y ‚àà [-10,10], z ‚àà [-5,5]" << std::endl;
        std::cout << "  - A√ßƒ± birimi radyan (œÄ = 3.14159)" << std::endl;
        std::cout << "  - Robot bir seferde bir komut √ßalƒ±≈ütƒ±rabilir" << std::endl;
        std::cout << "============================\n" << std::endl;
    }
    
    // Member variables
    rclcpp::Client<day2::srv::RobotCommand>::SharedPtr client_;
};

/**
 * Synchronous client √∂rneƒüi - command line'dan direkt kullanƒ±m
 */
void send_single_command(int argc, char* argv[])
{
    if (argc < 3) {
        std::cout << "Kullanƒ±m: " << argv[0] << " <command> [args...]" << std::endl;
        std::cout << "√ñrnek: " << argv[0] << " move 2.0 3.0 0.0" << std::endl;
        return;
    }
    
    rclcpp::init(argc, argv);
    auto node = std::make_shared<rclcpp::Node>("robot_command_client_sync");
    auto client = node->create_client<day2::srv::RobotCommand>("robot_command");
    
    // Service'i bekle
    if (!client->wait_for_service(10s)) {
        RCLCPP_ERROR(node->get_logger(), "Service not available");
        return;
    }
    
    // Command'ƒ± parse et
    auto request = std::make_shared<day2::srv::RobotCommand::Request>();
    std::string command = argv[1];
    
    if (command == "move" && argc >= 5) {
        request->command_type = "move_to";
        request->target_position.x = std::stod(argv[2]);
        request->target_position.y = std::stod(argv[3]);
        request->target_position.z = std::stod(argv[4]);
        request->max_velocity = 1.0;
    } else if (command == "stop") {
        request->command_type = "stop";
    } else if (command == "home") {
        request->command_type = "home";
    } else {
        std::cout << "Desteklenmeyen komut: " << command << std::endl;
        return;
    }
    
    // Synchronous call
    auto future = client->async_send_request(request);
    if (rclcpp::spin_until_future_complete(node, future) == rclcpp::FutureReturnCode::SUCCESS) {
        auto response = future.get();
        std::cout << "Response: " << (response->success ? "SUCCESS" : "FAILED") << std::endl;
        std::cout << "Message: " << response->message << std::endl;
    } else {
        std::cout << "Service call failed" << std::endl;
    }
    
    rclcpp::shutdown();
}

int main(int argc, char * argv[])
{
    // Command line'dan direkt komut varsa synchronous mode
    if (argc > 1) {
        send_single_command(argc, argv);
        return 0;
    }
    
    // Interactive mode
    rclcpp::init(argc, argv);
    auto client_node = std::make_shared<RobotCommandClient>();
    // Interactive mode kendi loop'unu y√∂netir, spin gerek yok
    rclcpp::shutdown();
    return 0;
}